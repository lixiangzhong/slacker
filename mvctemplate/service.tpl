//Generated by slacker
package service

import (
	"github.com/jmoiron/sqlx"
	"{{"gosrc/models"| .ImportLibrary}}/{{.Name}}"
	"{{"gosrc/scope"| .ImportLibrary}}"
	{{if .IsUserTable}}
	"{{"gosrc/errcode"| .ImportLibrary}}"
	{{end}}
)


func (s *Service)Take{{.CamelCaseName}}(data *{{.LowerName}}.{{.CamelCaseName}})error{ 
  err := s.dao.Take{{.CamelCaseName}}(data) 
	return   err 
}

func (s *Service)List{{.CamelCaseName}}(offset,limit uint64,search {{.LowerName}}.{{.CamelCaseName}})([]{{.LowerName}}.{{.CamelCaseName}},int,error){ 
	var where scope.Wheres
	{{if Contains .SwitchCase "state"}} 
		where=append(where,scope.Where("state!=?",{{.LowerName}}.StateDel)) 
	{{end}}
    total,err:=s.dao.Count(search,where...)
    if err!=nil{
        return nil,0,err
    }
	where=append(where,scope.OffsetLimit(offset, limit))
	where=append(where,scope.Order("{{.PrimaryKeyColumn.ColumnName}} desc")) 
	data,err := s.dao.List{{.CamelCaseName}}(where...)
	return data,total, err 
}

func (s *Service) Create{{.CamelCaseName}} (data *{{.LowerName}}.{{.CamelCaseName}}) error {
	{{if .IsUserTable}}
		data.{{.UsernameColumn.CamelCaseName}} = strings.ToLower(data.{{.UsernameColumn.CamelCaseName}})
		data.{{.PasswordColumn.CamelCaseName}} = s.EncryptPassword(data.{{.PasswordColumn.CamelCaseName}})
		if s.dao.{{.CamelCaseName}}IsExist(data.{{.UsernameColumn.CamelCaseName}}) {
			return errcode.AlreadyExist
		}
	{{end}}
	{{.AutomaticCreateUpdateExpression "data"}}
    err := s.dao.Create{{.CamelCaseName}}(data)
	return err
}

func (s *Service)Update{{.CamelCaseName}}(data {{.LowerName}}.{{.CamelCaseName}})error{
		 {{.AutomaticUpdateExpression "data"}}
	  return s.dao.Update{{.CamelCaseName}}(data)
	 
}

func (s *Service)Patch{{.CamelCaseName}}(id int64,update map[string]interface{})error{ 
	{{if .IsUserTable}}
		var {{.Initials}} {{.LowerName}}.{{.CamelCaseName}}
		{{.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}}=id
		err:=s.dao.Take{{.CamelCaseName}}(&{{.Initials}})
		if err!=nil{
			return err
		}
		if val, ok := update["{{.PasswordColumn.ColumnName}}"]; ok {
			password, ok := val.(string)
			if ok {
				if !s.ValidPassword(password, {{.Initials}}.{{.PasswordColumn.CamelCaseName}}) {
					return errcode.IncorrectUserOrPwd
				}
				password, _ = update["newpassword"].(string)
				update["{{.PasswordColumn.ColumnName}}"] = s.EncryptPassword(password)
			}
		}
	{{end}}
		{{.AutomaticUpdateMapExpression}}
	 return s.dao.Patch{{.CamelCaseName}}(id,update) 
}

func (s *Service)Delete{{.CamelCaseName}}(id int64)error{ 
	return s.dao.Delete{{.CamelCaseName}}(id)  
}

{{if .IsUserTable}}
func (s *Service) Take{{.CamelCaseName}}ByName(data *{{.LowerName}}.{{.CamelCaseName}})   error  { 
	return 	s.dao.Take{{.CamelCaseName}}ByName(data)  
}

func (_ *Service)EncryptPassword(password string) string {
	hashd, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(hashd)
}

func (_ *Service)ValidPassword(password,encryptedpwd string) bool {
	return nil == bcrypt.CompareHashAndPassword([]byte(encryptedpwd), []byte(password))
} 
{{end}}