//Generated by slacker
package dao

import (
	"github.com/jmoiron/sqlx"
	"github.com/jinzhu/gorm"
	"{{$.ProjectName}}/gosrc/log"
	"{{$.ProjectName}}/gosrc/models"
)

type Dao struct {
	db *sqlx.DB
	gorm *gorm.DB
}

func New(db *sqlx.DB) *Dao {
	d:= &Dao{
		db: db,
	}
	return d
}

func (d *Dao) Init() {
	d.initGorm()
	d.autoMigrate()
}

func (d *Dao) initGorm()  {
	db, err := gorm.Open("mysql", d.db.DB)
	if err != nil {
		log.Error(err)
	}
	d.gorm = db.Set("gorm:save_associations", false)
}

func (d *Dao) autoMigrate() {
	db:=d.gorm.Set("gorm:table_options", "ENGINE=InnoDB")
	models.Tables.Range(func(key, value interface{}) bool {
		db.AutoMigrate(value)
		return true
	})
}


func (d *Dao) Create(data interface{})error {
	return d.gorm.Create(data).Error
}

func (d *Dao) Update(data interface{},where ...func(*gorm.DB)*gorm.DB)error {
	return d.gorm.Scopes(where...).Save(data).Error
}

func (d *Dao) Patch(obj models.Table,u map[string]interface{},where ...func(*gorm.DB)*gorm.DB)error {
	return d.gorm.Table(obj.TableName()).Scopes(where...).UpdateColumns(u).Error
}

func (d *Dao) Delete(data interface{},where ...func(*gorm.DB)*gorm.DB)error {
	return d.gorm.Scopes(where...).Delete(data).Error
}

func (d *Dao) Take(data interface{},where ...func(*gorm.DB)*gorm.DB) error {
	return d.gorm.Scopes(where...).Take(data).Error
}

func (d *Dao) List(data interface{},where ...func(*gorm.DB)*gorm.DB) error {
	return d.gorm.Scopes(where...).Find(data).Error
}

func (d *Dao) Count(obj models.Table,where ...func(*gorm.DB)*gorm.DB)(int, error) {
	var total int
	err:= d.gorm.Table(obj.TableName()).Scopes(where...).Count(&total).Error
	return total,err
}
 
func (d *Dao) Tx(f func(tx *sqlx.Tx) error) error {
	tx, err := d.db.Beginx()
	if err != nil {
		return err
	}
	defer func() {
		if e := recover(); e != nil {
			log.Error(e)
			tx.Rollback()
		}
	}()
	err = f(tx)
	if err != nil {
		tx.Rollback()
		return err
	}
	return tx.Commit()
}

func (d *Dao) GormTx(f func(db *gorm.DB) error) error {
	tx := d.gorm.Begin()
	defer func() {
		if e := recover(); e != nil {
			log.Error(e)
			tx.Rollback()
		}
	}()
	err := f(tx)
	if err != nil {
		tx.Rollback()
		return err
	}
	return tx.Commit().Error
}